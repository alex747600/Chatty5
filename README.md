# Chatty
 Соцсеть Chatty

1. Создана виртуальная среда используя `venv`
2. Добавлены необходимые зависимости `requirements.txt`  pip install -r requirements.txt 
3. Установлены библиотеки: FastAPI, SQLAlchemy, Pydantic, Alembic


# Модели пользователей и постов (SQLAlchemy) 
 
 Модели и база данных
 
 -models.py:  
 - Определяет модели данных для таблиц users и posts.
 
 - Использует SQLAlchemy ORM для определения структуры таблиц и их полей.
 
 - Каждая модель соответствует таблице в базе данных и определяет поля,
 
 такие как id, email, password_hash и nickname (users)
 
 такие как  id, user_id, title, content и created_at (posts)
 
 - Используется relationship для установки двусторонней связи между users и posts.
 
 
 -database.py:
 - Настраивает подключение к базе данных с использованием SQLAlchemy.
 - Создает сессию для взаимодействия с базой данных.
 
 
 -db_base.py:
 - Использует SQLAlchemy.ext.declarative для импорта Base в models.py
 
 
 
# Миграции (Alembic)
 
 -alembic.ini и alembic/env.py:
 - Конфигурационные файлы для Alembic, инструмента для управления миграциями базы данных.
 - alembic.ini содержит основные настройки, такие как путь к скриптам миграций.
 - env.py настраивает окружение для выполнения миграций, подключаясь к базе данных и используя метаданные моделей.
 
 
 - 9014fe920ecd_initial_migration.py:
 
 - Автоматически сгенерированная миграция, которая создает таблицы users и posts в базе данных.
 - Содержит команды для создания и удаления таблиц и индексов.
 
   
 - Используемые команды
 
 - alembic init alembic
 - создание файла миграции: alembic revision --autogenerate -m "Initial migration"
 - применить миграцию: alembic upgrade head


CRUD для регистрации и авторизации
    - создал файлы : auth.py, security.py
    - добавлен эндпоинт для регистрации (POST: /auth/register) принимает email, пароль; при успехе сохраняет пользователя в БД.
    - добавлен эндпоинт для авторизации (POST: /auth/login) принимает email, пароль, выдаёт токен/сессию при успехе.
    - При повторной регистрации с существующим email возвращается ошибка (400 )
    - Пароли хранятся в хэшированном виде (bcrypt)
    - в  main.py добавил rout на auth.py



Разделение монолита на микросервисы:

1. Создаем отдельные директории для каждого микросервиса (auth, post....) .
2. В каждой директории создаем файл main.py, который будет являться точкой входа для микросервиса.
3. Создаем файл requirements.txt для каждого микросервиса, в котором указываем необходимые зависимости.
4. Создаем файл Dockerfile для каждого микросервиса, c инструкции по сборке образа и назначаем порты.
5. Создаем файл docker-compose.yml, в котором описываем все сервисы и их зависимости (БД, брокер сообщений..).
6. Переносим .env от прошлой конфигурации (пароли, ключи и т.д.) и добавляем его в .gitignore.
7. Разносим по папкам соответствующие файлы из папки арр.




# Subscription_service

## Обзор

**Сервис подписок** — это микросервис, разработанный на Python с использованием FastAPI, предназначенный для управления подписками пользователей и их лентой в приложении, похожем на социальную сеть. Сервис позволяет пользователям подписываться на других пользователей, отписываться, просматривать свои подписки, подписчиков и ленту постов от тех, на кого они подписаны. Сервис взаимодействует с внешними микросервисами для аутентификации (`Auth Service`) и постов (`Post Service`), а также использует базу данных PostgreSQL для хранения данных о подписках.

Этот сервис является частью микросервисной архитектуры, использует асинхронное программирование, аутентификацию на основе JWT и библиотеку Pydantic для валидации данных. Включает заглушку для кэширования (для будущей реализации) для оптимизации получения ленты.

## Функциональность

- **Подписки пользователей**: Подписка и отписка от других пользователей по их ID или имени пользователя.
- **Лента пользователя**: Получение ленты постов от пользователей, на которых подписан текущий пользователь.
- **Подписчики и подписки**: Просмотр списка пользователей, которые подписаны на текущего пользователя, и списка тех, на кого подписан текущий пользователь.
- **Аутентификация**: Защита эндпоинтов с использованием JWT-токенов.
- **Асинхронность**: Построен на `async/await` для высокой производительности API.
- **База данных**: Хранение данных о подписках в PostgreSQL с использованием ORM SQLAlchemy.
- **Интеграция с микросервисами**: Взаимодействие с `Auth Service` для получения данных о пользователях и с `Post Service` для получения постов.

## Структура 

```plaintext
subscription_service/
├── alembic/                    # Миграции базы данных
│   ├── env.py
│   ├── script.py.mako
│   └── versions/
│       └── 1e89a5383764_initial_migration.py
├── app/
│   ├── clients/                # Клиенты для внешних сервисов
│   │   ├── auth_client.py      # Взаимодействие с Auth Service
│   │   └── post_client.py      # Взаимодействие с Post Service
│   ├── core/                   # Конфигурация и зависимости
│   │   ├── config.py           # Настройки приложения из .env
│   │   └── deps.py             # Зависимости FastAPI (например, JWT-аутентификация)
│   ├── routers/                
│   │   └── subscriptions.py    # Маршруты FastAPI для подписок
│   ├── services/               # Бизнес-логика
│   │   └── subscription_service.py  # Логика, связанная с подписками
│   ├── utils/                 
│   │   └── cache.py            # Логика кэширования (заглушка)
│   ├── database.py             # Конфигурация базы данных
│   ├── models.py               # Модель подписок
│   └── schemas.py              # Схемы для Post, Subscription, User
└── alembic.ini                 # Конфигурация Alembic
├── app.py                      # rabbitmq
├── db_base                     # base
├── docker-entrypoint.sh        # Инструкция ENTRYPOINT
├── Dockerfile                  # Docker-образ сервиса
├── main.py                     # Инициализация FastAPI
├── requirements.txt            # Переменные окружения
```

## Требования

- Python 3.9+
- PostgreSQL (для хранения данных о подписках)
- RabbitMQ (опционально, для будущей интеграции с очередями сообщений)
- Доступ к API `Auth Service` и `Post Service`
- Docker (опционально, для развертывания в контейнерах)

## Установка

1. **Клонируйте репозиторий**:
   ```bash
   git clone https://github.com/<ваш-репозиторий>/subscription_service.git
   cd subscription_service
   ```

2. **Создайте виртуальное окружение**:
   ```bash
   python -m venv venv
   source venv/bin/activate  # Для Windows: venv\Scripts\activate
   ```

3. **Установите зависимости**:
   ```bash
   pip install -r requirements.txt
   ```

   *Примечание*: Если файл `requirements.txt` отсутствует, установите следующие библиотеки:
   ```bash
   pip install fastapi uvicorn sqlalchemy asyncpg httpx pydantic pydantic-settings python-jose python-dotenv
   ```

4. **Настройте переменные окружения**:
   Создайте файл `.env` в корне проекта со следующими переменными:
   ```plaintext
   SUBSCRIPTION_DB_URL=postgresql+asyncpg://user:password@localhost:5432/subscriptions
   RABBITMQ_HOST=localhost
   RABBITMQ_PORT=5672
   AUTH_SERVICE_URL=http://auth-service:8003
   POST_SERVICE_URL=http://post-service:8006
   JWT_SECRET=your_jwt_secret_key
   JWT_ALGORITHM=HS256
   JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30
   DEBUG=True
   ```

5. **Настройте базу данных**:
   - Убедитесь, что PostgreSQL запущен.
   - Создайте базу данных с именем `subscriptions`.
   - Схема базы данных будет создана автоматически SQLAlchemy при первом запуске.

6. **Запустите приложение**:
   ```bash
   uvicorn app.subscriptions:app --host 0.0.0.0 --port 8007 --reload
   ```

   API будет доступен по адресу `http://localhost:8007`.

## Эндпоинты API

Сервис предоставляет REST API с эндпоинтами под префиксом `/subscriptions`:

| Метод  | Эндпоинт                            | Описание                                        | Аутентификация |
|--------|-------------------------------------|-------------------------------------------------|----------------|
| GET    | `/users`                           | Получить список всех пользователей              | JWT-токен      |
| POST   | `/subscribe/{user_id}`             | Подписаться на пользователя по ID               | JWT-токен      |
| POST   | `/subscribe/username/{username}`   | Подписаться на пользователя по имени            | JWT-токен      |
| DELETE | `/unsubscribe/{user_id}`           | Отписаться от пользователя по ID                | JWT-токен      |
| GET    | `/users/{user_id}/posts`           | Получить все посты пользователя                 | JWT-токен      |
| GET    | `/subscriptions`                   | Получить список подписок текущего пользователя  | JWT-токен      |
| GET    | `/following`                       | Получить ID пользователей, на которых подписан  | JWT-токен      |
| GET    | `/followers`                       | Получить ID подписчиков текущего пользователя   | JWT-токен      |
| GET    | `/feed`                            | Получить ленту постов от подписанных пользователей | JWT-токен    |

### Пример запроса

**Подписка на пользователя по ID**:
```bash
curl -X POST "http://localhost:8007/subscriptions/subscribe/2" \
     -H "Authorization: Bearer <ваш_jwt_токен>"
```

**Ответ**:
```json
{
  "detail": "Subscribed successfully"
}
```

### Документация API

Интерактивная документация API (на основе Swagger UI от FastAPI) доступна по адресу:
```
http://localhost:8002/docs
```

## Архитектура

Сервис подписок построен на микросервисной архитектуре со следующими компонентами:

1. **FastAPI**: Обработка HTTP-запросов и предоставление REST API.
2. **SQLAlchemy (ORM)**: Управление базой данных PostgreSQL для хранения подписок.
3. **Pydantic**: Валидация и сериализация данных для запросов и ответов API.
4. **HTTPX**: Выполнение асинхронных HTTP-запросов к внешним сервисам (`Auth Service`, `Post Service`).
5. **JWT-аутентификация**: Защита эндпоинтов с использованием JWT-токенов, проверяемых через `Auth Service`.
6. **Кэширование (заглушка)**: Планируется для оптимизации получения ленты (например, с использованием Redis).

### Внешние зависимости

- **Auth Service**: Предоставляет данные пользователей и аутентификацию (например, ID пользователя по имени или токену).
- **Post Service**: Предоставляет посты пользователей для ленты и запросов постов конкретного пользователя.
- **PostgreSQL**: Хранит данные о подписках (отношения между пользователями).

### Модель данных

База данных содержит одну таблицу `subscriptions`, определённую в `models.py`:
- `id`: Первичный ключ.
- `user_id`: ID пользователя, на которого подписаны (внешний ключ к таблице `users`).
- `follower_id`: ID пользователя, который подписывается (внешний ключ к таблице `users`).

### Поток аутентификации

1. Клиент отправляет JWT-токен в заголовке `Authorization: Bearer <токен>`.
2. Зависимость `get_current_user` (`deps.py`) декодирует токен с использованием `JWT_SECRET` и извлекает `user_id`.
3. `user_id` используется для идентификации текущего пользователя в операциях с подписками.

## Разработка

### Запуск тестов

*Примечание*: Тесты отсутствуют в текущем коде. Для добавления тестов используйте `pytest` с `pytest-asyncio` для асинхронных эндпоинтов.

1. Установите зависимости для тестирования:
   ```bash
   pip install pytest pytest-asyncio httpx
   ```

2. Запустите тесты:
   ```bash
   pytest
   ```

### Отладка

- Установите `DEBUG=True` в файле `.env` для включения логирования запросов SQLAlchemy.
- Используйте флаг `--reload` с `uvicorn` для автоматической перезагрузки при разработке.





# Admin_service

**Admin Service** — это микросервис на базе [FastAPI](https://fastapi.tiangolo.com/), предназначенный для административного управления платформой. Он предоставляет функциональность для управления пользователями, модерации контента, просмотра аудит-логов, получения статистики платформы и статистики активности пользователей. Сервис взаимодействует с **Auth Service** (управление пользователями) и **Post Service** (управление постами, комментариями и активностью) через REST API.

Все эндпоинты защищены **JWT-аутентификацией** и доступны только пользователям с ролью администратора (`role == 0`). Действия администраторов логируются в таблицу `audit_log` в базе данных PostgreSQL и в [Sentry](https://sentry.io/) для мониторинга и отладки. Сервис поддерживает контейнеризацию с помощью Docker и автоматизированное тестирование через GitHub Actions.

---

## Содержание

- [Функциональность](#функциональность)
- [Требования](#требования)
- [Установка и настройка](#установка-и-настройка)
  - [Локальная установка](#локальная-установка)
  - [Запуск с Docker](#запуск-с-docker)
- [Переменные окружения](#переменные-окружения)
- [Схема базы данных](#схема-базы-данных)
- [Роли пользователей](#роли-пользователей)
- [Эндпоинты API](#эндпоинты-api)
  - [Управление пользователями](#управление-пользователями)
  - [Модерация контента](#модерация-контента)
  - [Аудит-логи](#аудит-логи)
  - [Статистика платформы](#статистика-платформы)
  - [Статистика активности пользователей](#статистика-активности-пользователей)
  - [Проверка состояния](#проверка-состояния)
- [Документация API](#документация-api)
- [Тестирование](#тестирование)
- [CI/CD](#cicd)
- [Мониторинг](#мониторинг)
- [Структура проекта](#структура-проекта)
- [Часто задаваемые вопросы](#часто-задаваемые-вопросы)
- [Контакты](#контакты)

---

## Функциональность

Admin Service предоставляет следующие возможности:

- **Управление пользователями**:
  - Получение списка пользователей.
  - Блокировка и разблокировка пользователей.
  - Изменение роли пользователя (админ, модератор, пользователь).
  - Удаление пользователей с указанием причины.
- **Модерация контента**:
  - Удаление постов и комментариев.
- **Аудит-логирование**:
  - Просмотр всех действий администраторов (например, блокировка пользователя, удаление поста).
- **Статистика платформы**:
  - Получение данных о количестве пользователей (всего, заблокированных, активных), постов и комментариев.
- **Статистика активности пользователей**:
  - Получение метрик активности (активные пользователи, созданные посты и комментарии).
- **Мониторинг**:
  - Логирование действий и ошибок в Sentry.
- **Безопасность**:
  - Доступ к эндпоинтам только для администраторов (`role == 0`) через JWT-аутентификацию.
- **Тестирование**:
  - Юнит- и интеграционные тесты для проверки функциональности и интеграции с внешними сервисами.
- **CI/CD**:
  - Автоматизированное тестирование и сборка Docker-образа через GitHub Actions.

---

## Требования

Для работы с Admin Service необходимы:

- **Python**: 3.12 или выше.
- **Docker** и **Docker Compose** (для контейнеризации).
- **PostgreSQL**: 16 или выше (используется как основная база данных).
- **Зависимости Python**:
  - Указаны в `requirements.txt` (FastAPI, SQLAlchemy, PyJWT, Sentry-SDK и др.).
- **Доступ к внешним сервисам**:
  - **Auth Service**: Для управления пользователями (по умолчанию `http://auth_service:8003`).
  - **Post Service**: Для управления постами, комментариями и активностью (по умолчанию `http://post_service:8006`).
- **Sentry DSN** (опционально): Для мониторинга ошибок и действий.
- **JWT_SECRET**: Секретный ключ для проверки JWT-токенов.

---

## Установка и настройка

### Локальная установка

1. **Клонируйте репозиторий**:
   ```bash
   git clone <repository-url>
   cd admin_service
   ```

2. **Создайте виртуальное окружение**:
   ```bash
   python -m venv venv
   source venv/bin/activate  # Для Windows: venv\Scripts\activate
   ```

3. **Установите зависимости**:
   ```bash
   pip install -r requirements.txt
   ```

4. **Настройте переменные окружения**:
   - Создайте файл `.env` в корне проекта или задайте переменные вручную (см. [Переменные окружения](#переменные-окружения)).
   - Пример:
     ```bash
     export DATABASE_URL=postgresql://user:password@localhost:5432/admin_db
     export AUTH_SERVICE_URL=http://localhost:8003
     export POST_SERVICE_URL=http://localhost:8006
     export SENTRY_DSN=<your-sentry-dsn>
     export JWT_SECRET=your_very_secure_random_key_32_chars_long
     ```

5. **Настройте базу данных**:
   - Убедитесь, что PostgreSQL запущен и доступен.
   - Примените миграции с помощью Alembic:
     ```bash
     alembic upgrade head
     ```

6. **Запустите сервис**:
   ```bash
   uvicorn app.main:app --host 0.0.0.0 --port 8009 --reload
   ```
   - Сервис будет доступен по адресу `http://localhost:8009`.

### Запуск с Docker

1. **Клонируйте репозиторий** (если ещё не сделано):
   ```bash
   git clone <repository-url>
   cd admin_service
   ```

2. **Создайте файл `.env`** с необходимыми переменными (см. [Переменные окружения](#переменные-окружения)).

3. **Запустите сервисы с помощью Docker Compose**:
   ```bash
   docker-compose up --build
   ```
   - Это запустит Admin Service, PostgreSQL и другие сервисы, указанные в `docker-compose.yml`.

4. **Примените миграции базы данных**:
   ```bash
   docker-compose exec admin_service alembic upgrade head
   ```

5. **Проверьте доступность**:
   - Admin Service будет доступен по адресу `http://localhost:8009`.
   - Документация API доступна по `http://localhost:8009/docs`.

---

## Переменные окружения

Admin Service использует следующие переменные окружения:

| Переменная           | Описание                                                                 | Значение по умолчанию                         |
|----------------------|--------------------------------------------------------------------------|-----------------------------------------------|
| `DATABASE_URL`       | Строка подключения к PostgreSQL                                          | `postgresql://user:password@db:5432/admin_db` |
| `AUTH_SERVICE_URL`   | URL Auth Service для управления пользователями                            | `http://auth_service:8003`                    |
| `POST_SERVICE_URL`   | URL Post Service для управления постами, комментариями и активностью     | `http://post_service:8006`                    |
| `SENTRY_DSN`         | DSN для Sentry (для мониторинга ошибок и действий)                       | (опционально, без значения)                   |
| `JWT_SECRET`         | Секретный ключ для проверки JWT-токенов                                  | `your_very_secure_random_key_32_chars_long`                             |

**Примечание**: Для безопасности рекомендуется хранить `SENTRY_DSN` и `JWT_SECRET` в секретах (например, в GitHub Secrets для CI/CD).

---

## Схема базы данных

Admin Service использует PostgreSQL с одной таблицей:

### Таблица `audit_log`

Хранит записи о действиях администраторов для аудита.

| Поле         | Тип данных | Описание                                              |
|--------------|------------|-------------------------------------------------------|
| `id`         | Integer    | Первичный ключ, уникальный идентификатор записи        |
| `admin_id`   | Integer    | ID администратора, выполнившего действие              |
| `action`     | String     | Тип действия (например, `block_user`, `delete_post`)  |
| `target_id`  | Integer    | ID цели действия (пользователь, пост, комментарий)    |
| `reason`     | String     | Причина действия (опционально, например, для удаления)|
| `timestamp`  | DateTime   | Время выполнения действия (UTC)                       |

**Пример записи**:
```sql
INSERT INTO audit_log (admin_id, action, target_id, reason, timestamp)
VALUES (1, 'delete_user', 2, 'Нарушение правил', '2025-05-04 10:00:00');
```

**Миграции**:
- Схема создаётся и обновляется с помощью [Alembic](https://alembic.sqlalchemy.org/). Файлы миграций находятся в директории `alembic/versions/`.

---

## Роли пользователей

Admin Service поддерживает следующие роли пользователей (определяются в Auth Service):

| Роль          | Код (`role`)    | Описание                                              |
|---------------|-----------------|-------------------------------------------------------|
| Администратор | 0               | Полный доступ ко всем эндпоинтам Admin Service        |
| Модератор     | 1               | Нет доступа к эндпоинтам Admin Service                |
| Пользователь  | 2               | Нет доступа к эндпоинтам Admin Service                |

**Примечание**: Все эндпоинты Admin Service требуют `role == 0` и действительный JWT-токен, содержащий поля `sub` (user_id) и `role`.

---

## Эндпоинты API

Все эндпоинты находятся под префиксом `/admin` и требуют заголовок `Authorization: Bearer <JWT_TOKEN>` с токеном, где `role == 0`. Ниже приведены основные эндпоинты.

### Управление пользователями

- **GET /admin/users**
  - **Описание**: Возвращает список всех пользователей.
  - **Ответ** (200):
    ```json
    {
      "users": [
        {
          "id": 1,
          "username": "admin",
          "email": "admin@example.com",
          "role": 0,
          "is_blocked": false
        },
        ...
      ]
    }
    ```
  - **Ошибки**:
    - 401: Неверный или отсутствующий токен.
    - 403: Недостаточно прав (не админ).
    - 503: Auth Service недоступен.

- **POST /admin/users/{user_id}/block**
  - **Описание**: Блокирует пользователя.
  - **Ответ** (200):
    ```json
    {"message": "User {user_id} blocked"}
    ```
  - **Ошибки**: 401, 403, 503.

- **POST /admin/users/{user_id}/unblock**
  - **Описание**: Разблокирует пользователя.
  - **Ответ** (200):
    ```json
    {"message": "User {user_id} unblocked"}
    ```

- **PUT /admin/users/{user_id}/role**
  - **Описание**: Изменяет роль пользователя.
  - **Тело запроса**:
    ```json
    {"role": 1}
    ```
  - **Ответ** (200):
    ```json
    {"message": "Role updated for user {user_id}"}
    ```

- **DELETE /admin/users/{user_id}**
  - **Описание**: Удаляет пользователя.
  - **Тело запроса**:
    ```json
    {"reason": "Нарушение правил"}
    ```
  - **Ответ** (200):
    ```json
    {"message": "User {user_id} deleted"}
    ```

### Модерация контента

- **DELETE /admin/posts/{post_id}**
  - **Описание**: Удаляет пост.
  - **Ответ** (200):
    ```json
    {"message": "Post {post_id} deleted"}
    ```
  - **Ошибки**:
    - 404: Пост не найден.
    - 503: Post Service недоступен.

- **DELETE /admin/comments/{comment_id}**
  - **Описание**: Удаляет комментарий.
  - **Ответ** (200):
    ```json
    {"message": "Comment {comment_id} deleted"}
    ```
  - **Ошибки**: 404, 503.

### Аудит-логи

- **GET /admin/logs**
  - **Описание**: Возвращает список всех аудит-логов.
  - **Ответ** (200):
    ```json
    {
      "logs": [
        {
          "id": 1,
          "admin_id": 1,
          "action": "delete_user",
          "target_id": 2,
          "reason": "Нарушение правил",
          "timestamp": "2025-05-04T10:00:00Z"
        },
        ...
      ]
    }
    ```

### Статистика платформы

- **GET /admin/stats**
  - **Описание**: Возвращает общую статистику платформы.
  - **Ответ** (200):
    ```json
    {
      "total_users": 100,
      "blocked_users": 5,
      "active_users": 80,
      "total_posts": 500,
      "total_comments": 1000
    }
    ```
  - **Ошибки**: 503 (Auth/Post Service недоступны).

### Статистика активности пользователей

- **GET /admin/activity**
  - **Описание**: Возвращает метрики активности пользователей.
  - **Ответ** (200):
    ```json
    {
      "total_active_users": 50,
      "posts_created": 100,
      "comments_created": 200
    }
    ```
  - **Ошибки**: 503 (Post Service недоступен).

### Проверка состояния

- **GET /health**
  - **Описание**: Проверяет состояние сервиса.
  - **Ответ** (200):
    ```json
    {"status": "healthy"}
    ```

---

## Документация API

Интерактивная документация API доступна через Swagger UI:

- **URL**: `http://localhost:8009/docs`
- **Описание**: Swagger автоматически генерирует документацию на основе кода FastAPI, позволяя тестировать эндпоинты прямо в браузере.
- **Альтернатива**: ReDoc доступен по `http://localhost:8009/redoc`.

Для тестирования эндпоинтов в Swagger:
1. Нажмите кнопку "Authorize".
2. Введите JWT-токен в формате `Bearer <token>`.
3. Выполняйте запросы к эндпоинтам.

**Примечание**: Токены выдаются Auth Service (предполагается внешний эндпоинт `/token`).

---

## Тестирование

Admin Service включает юнит- и интеграционные тесты для проверки функциональности и интеграции.

### Запуск тестов

1. Убедитесь, что зависимости установлены:
   ```bash
   pip install -r requirements.txt
   ```

2. Настройте переменные окружения (например, `DATABASE_URL`).

3. Запустите тесты:
   ```bash
   pytest app/tests
   ```

### Структура тестов

- **Юнит-тесты**:
  - Расположены в `app/tests/test_*.py` (например, `test_users.py`, `test_stats.py`).
  - Проверяют логику эндпоинтов с использованием моков для внешних сервисов (Auth/Post Service).
- **Интеграционные тесты**:
  - Расположены в `app/tests/integration/test_integration.py`.
  - Проверяют взаимодействие с Auth Service, Post Service и базой данных.
  - Примеры:
    - Проверка `GET /admin/activity` (возвращает статистику, логирует действие).
    - Проверка `DELETE /admin/posts/{post_id}` (обрабатывает 404 для несуществующих постов).

**Зависимости для тестов**:
- Требуется запущенная PostgreSQL.
- Для интеграционных тестов нужны доступные Auth Service и Post Service (или их моки).

---

## CI/CD

Admin Service использует **GitHub Actions** для автоматизации тестирования и сборки.

### Конфигурация

Файл `.github/workflows/ci.yml` определяет процесс CI/CD:

- **Триггеры**: Запускается при `push` или `pull_request` на ветку `main`.
- **Задачи**:
  - **Test**:
    - Запускает PostgreSQL в контейнере.
    - Устанавливает Python 3.12 и зависимости.
    - Выполняет тесты с помощью `pytest app/tests`.
  - **Build**:
    - Выполняется после успешных тестов.
    - Собирает Docker-образ сервиса (`admin_service:latest`) на основе `Dockerfile`.

### Запуск CI/CD

1. Создайте pull request или push в ветку `main`.
2. GitHub Actions автоматически запустит тесты и сборку.
3. Проверьте результаты в разделе "Actions" репозитория GitHub.

**Примечание**: Убедитесь, что `SENTRY_DSN` добавлен в секреты GitHub для безопасного логирования.

---

## Мониторинг

Admin Service использует [Sentry](https://sentry.io/) для мониторинга:

- **Ошибки**: Все исключения (например, недоступность Auth/Post Service) логируются в Sentry с контекстом (например, `user_id`, `action`).
- **Действия**: Каждое действие админа (например, `delete_user`, `view_stats`) отправляется в Sentry для отслеживания.
- **Конфигурация**:
  - Sentry инициализируется в `app/utils.py` с помощью функции `init_sentry`.
  - Требуется переменная окружения `SENTRY_DSN`.

**Пример лога в Sentry**:
- Действие: `delete_user`
- Контекст: `user_id=1, target_id=2, reason="Нарушение правил"`

**Зачем нужно**: Sentry позволяет отслеживать ошибки в реальном времени и анализировать действия админов, что упрощает отладку и аудит.

---

## Структура

```
admin_service/
├── alembic/                    # Миграции базы данных
│   ├── env.py
│   ├── script.py.mako
│   └── versions/
│       └── 001_create_audit_log.py
├── app/
│   ├── __init__.py
│   ├── main.py             # Инициализация FastAPI
│   ├── database.py         # Конфигурация PostgreSQL
│   ├── models.py           # Модель audit_log (SQLAlchemy)
│   ├── utils.py            # Логирование в Sentry
│   ├── dependencies.py     # JWT-аутентификация
│   ├── schemas.py          # Pydantic-модели
│   ├── routers/
│   │   ├── users.py        # Эндпоинты управления пользователями
│   │   ├── content.py      # Эндпоинты модерации контента
│   │   ├── logs.py         # Эндпоинт аудит-логов
│   │   ├── stats.py        # Эндпоинт статистики платформы
│   │   ├── activity.py     # Эндпоинт статистики активности
│   ├── tests/
│   │   ├── test_users.py
│   │   ├── test_content.py
│   │   ├── test_logs.py
│   │   ├── test_stats.py
│   │   ├── integration/
│   │   │   ├── test_integration.py
├── Dockerfile              # Docker-образ сервиса
├── docker-entrypoint       # Инструкция ENTRYPOINT      
├── requirements.txt        # Зависимости Python
└── alembic.ini             # Конфигурация Alembic
```

**Описание**:
- **alembic/**: Хранит миграции для создания/обновления таблицы `audit_log`.
- **app/**: Основной код сервиса, разделённый на модули для маршрутов, моделей и утилит.
- **tests/**: Юнит- и интеграционные тесты.
- **Dockerfile, docker-compose.yml**: Настройка контейнеризации. 

 
